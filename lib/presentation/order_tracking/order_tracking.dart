import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:url_launcher/url_launcher.dart';

import 'widgets/delivery_map_widget.dart';
import 'widgets/order_header_widget.dart';
import 'widgets/order_items_list.dart';
import 'widgets/order_status_timeline.dart';
import '../../core/app_export.dart';
import '../../services/local_storage.dart';
import 'package:farmmarket/services/supabase_service.dart';
import 'package:farmmarket/services/whatsapp_service.dart';
import 'package:latlong2/latlong.dart';

class OrderTracking extends StatefulWidget {
  const OrderTracking({super.key});

  @override
  State<OrderTracking> createState() => _OrderTrackingState();
}

class _OrderTrackingState extends State<OrderTracking> {
  String _orderId = '';
  OrderStatus _currentStatus = OrderStatus.confirmed;
  bool _isLoading = true;
  bool _notificationsEnabled = true;
  String? _farmerName;
  String _deliveryAddress = '';
  LatLng? _buyerPos;
  LatLng? _sellerPos;
  String? _buyerEmail;
  String? _ownerId;
  bool _isOwner = false;
  String? _buyerId;
  bool _isParticipant = true;
  bool _isBuyer = false;
  List<String> _paymentProofUrls = [];

  // Live order status syncing
  Map<String, dynamic>? _orderRow;

  // Order header fallbacks
  final String _orderNumber = 'FM-ORDER';
  final DateTime _orderDate = DateTime.now();
  double _totalAmount = 0.0;

  late List<OrderStatusData> _statusList;
  late List<OrderItem> _orderItems;

  @override
  void initState() {
    super.initState();
    _initializeOrderData();
    _loadOrderData();
  }

  Future<void> _launchUpiPay() async {
    try {
      if (_ownerId == null) {
        _showSnackBar('Seller info not available');
        return;
      }
      final upi = await SupabaseService.getProfileUpiId(_ownerId!);
      if (upi == null || upi.isEmpty) {
        _showSnackBar('Seller UPI ID not set');
        return;
      }
      final sellerName = _farmerName ?? 'Seller';
      final amountStr = _totalAmount.toStringAsFixed(2);
      final note = Uri.encodeComponent('Order Payment $_orderId');
      final uri = Uri.parse('upi://pay?pa=$upi&pn=${Uri.encodeComponent(sellerName)}&am=$amountStr&cu=INR&tn=$note');
      if (kIsWeb) {
        // On web/desktop browsers, upi:// links usually won't open an app.
        // Show a QR + link so the buyer can scan or copy to a mobile device.
        _showWebUpiDialog(uri.toString());
        return;
      }
      if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {
        _showSnackBar('Could not open UPI app');
      }
    } catch (_) {
      _showSnackBar('Could not open UPI app');
    }
  }

  void _showWebUpiDialog(String upiLink) {
    final qrData = Uri.encodeComponent(upiLink);
    final qrUrl = 'https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=$qrData';
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Pay via UPI'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // QR code generated by a public QR service (no extra dependency)
            Image.network(qrUrl, width: 240, height: 240, errorBuilder: (_, __, ___) {
              return const SizedBox(
                  width: 240, height: 240, child: Center(child: Text('QR unavailable')));
            }),
            const SizedBox(height: 12),
            Text('Scan with any UPI app', style: GoogleFonts.inter(fontWeight: FontWeight.w600)),
            const SizedBox(height: 12),
            Align(
              alignment: Alignment.centerLeft,
              child: Text('Or copy this UPI link:', style: GoogleFonts.inter()),
            ),
            const SizedBox(height: 6),
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surfaceVariant,
                borderRadius: BorderRadius.circular(8),
              ),
              child: SelectableText(upiLink, style: GoogleFonts.inter(fontSize: 12)),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () async {
              await Clipboard.setData(ClipboardData(text: upiLink));
              if (mounted) _showSnackBar('UPI link copied');
            },
            child: const Text('Copy Link'),
          ),
          TextButton(
            onPressed: () async {
              final ok = await launchUrl(Uri.parse(upiLink), mode: LaunchMode.externalApplication);
              if (!ok && mounted) _showSnackBar('Could not open UPI link');
            },
            child: const Text('Open Link'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }

  Future<void> _uploadPaymentProof() async {
    try {
      if (_orderId.isEmpty) return;
      if (!kIsWeb) {
        final photos = await Permission.photos.request();
        if (!photos.isGranted && !photos.isLimited) {
          final storage = await Permission.storage.request();
          if (!storage.isGranted) {
            _showSnackBar('Photos permission required');
            return;
          }
        }
      }
      final picker = ImagePicker();
      final x = await picker.pickImage(source: ImageSource.gallery, maxWidth: 1600, imageQuality: 85);
      if (x == null) return;
      final bytes = await x.readAsBytes();
      // Upload to storage bucket 'payment-proofs'
      final user = SupabaseService.currentUserId ?? 'anon';
      final path = 'orders/$_orderId/${DateTime.now().millisecondsSinceEpoch}_$user.jpg';
      final url = await SupabaseService.uploadImage(
        bucket: 'payment-proofs',
        path: path,
        bytes: bytes,
        contentType: 'image/jpeg',
      );
      await SupabaseService.insertPaymentProof(orderId: _orderId, url: url);
      // Update local list
      setState(() {
        _paymentProofUrls.add(url);
      });
      // Move to payment_confirmation status so seller can review
      setState(() {
        _currentStatus = OrderStatus.paymentConfirmation;
      });
      await _persistStatusToSupabase();
      // Notify seller
      if (_ownerId != null) {
        // ignore: unawaited_futures
        SupabaseService.sendPushToUser(
          userId: _ownerId!,
          title: 'Payment proof uploaded',
          body: 'Order $_orderId has a new payment proof to review.',
          data: {'type': 'payment_proof', 'order_id': _orderId},
        );
      }
      _showSnackBar('Payment proof uploaded');
    } catch (_) {
      _showSnackBar('Failed to upload payment proof');
    }
  }

  // Timeline actions
  void _approveCurrentStep() {
    setState(() {
      // Mark current as completed and advance
      final idx = _statusList.indexWhere((s) => s.status == _currentStatus);
      if (idx != -1) {
        final s = _statusList[idx];
        final acceptedSubtitle = (_currentStatus == OrderStatus.paymentConfirmation)
            ? 'Payment accepted'
            : (_currentStatus == OrderStatus.delivered)
                ? s.subtitle
                : 'Accepted';
        _statusList[idx] = OrderStatusData(
          status: s.status,
          title: s.title,
          subtitle: acceptedSubtitle,
          timestamp: DateTime.now(),
          isCompleted: true,
          estimatedTime: s.estimatedTime,
        );

        // If owner confirms the order, notify buyer by email
        if (_isOwner && s.status == OrderStatus.confirmed) {
          // Stock already decremented at order placement; avoid double-decrement here
          final email = _buyerEmail;
          final orderId = _orderId;
          // Insert sales if not already inserted at cart confirm
          final buyerId = _buyerId;
          // ignore: unawaited_futures
          (() async {
            if (orderId.isNotEmpty && !(await SupabaseService.hasSalesForOrder(orderId))) {
              final sellerId = _ownerId;
              if (sellerId != null) {
                for (final it in _orderItems) {
                  await SupabaseService.insertSale(data: {
                    'order_id': orderId,
                    if (buyerId != null) 'buyer_id': buyerId,
                    'seller_id': sellerId,
                    'product_id': it.id,
                    'product_name': it.name,
                    'quantity': it.quantity,
                    'line_total': it.price,
                  });
                }
              }
            }
          })();
          (() async {
            String? targetEmail = email;
            if ((targetEmail == null || targetEmail.isEmpty) && _buyerId != null) {
              targetEmail = await SupabaseService.getUserEmailFromProfile(_buyerId!);
            }
            if (targetEmail != null && targetEmail.isNotEmpty && orderId.isNotEmpty) {
              await SupabaseService.sendBuyerOrderConfirmedEmail(
                buyerEmail: targetEmail,
                orderId: orderId,
                items: _orderItems
                    .map((it) => {
                          'name': it.name,
                          'quantity': it.quantity,
                          'price': it.price,
                        })
                    .toList(),
                totalAmount: _totalAmount,
              );
            }
          })();
          // Buyer push: Order Confirmed
          if (_buyerId != null && orderId.isNotEmpty) {
            // ignore: unawaited_futures
            SupabaseService.sendPushToUser(
              userId: _buyerId!,
              title: 'Order Confirmed',
              body: 'Your order $orderId has been confirmed.',
              data: {
                'type': 'order_confirmed',
                'order_id': orderId,
              },
            );
          }
        }

        // If delivered step approved, mark items sold and notify buyer by email (fire-and-forget)
        if (s.status == OrderStatus.delivered) {
          // Ensure stock is decremented (idempotent if already done on confirm)
          for (final it in _orderItems) {
            // ignore: unawaited_futures
            SupabaseService.decrementProductStock(productId: it.id, quantity: it.quantity);
          }
          final email = _buyerEmail;
          final orderId = _orderId;
          (() async {
            String? targetEmail = email;
            if ((targetEmail == null || targetEmail.isEmpty) && _buyerId != null) {
              targetEmail = await SupabaseService.getUserEmailFromProfile(_buyerId!);
            }
            if (targetEmail != null && targetEmail.isNotEmpty && orderId.isNotEmpty) {
              await SupabaseService.sendBuyerDeliveredEmail(
                buyerEmail: targetEmail,
                orderId: orderId,
                items: _orderItems
                    .map((it) => {
                          'name': it.name,
                          'quantity': it.quantity,
                          'price': it.price,
                        })
                    .toList(),
                totalAmount: _totalAmount,
              );
            }
          })();
          // Buyer push: Order Delivered
          if (_buyerId != null && orderId.isNotEmpty) {
            // ignore: unawaited_futures
            SupabaseService.sendPushToUser(
              userId: _buyerId!,
              title: 'Order Delivered',
              body: 'Your order $orderId has been delivered.',
              data: {
                'type': 'order_delivered',
                'order_id': orderId,
              },
            );
          }
        }
      }
      // Advance to next if exists
      final provided = _statusList.map((e) => e.status).toList();
      final currentIndex = provided.indexOf(_currentStatus);
      if (currentIndex != -1 && currentIndex + 1 < provided.length) {
        _currentStatus = provided[currentIndex + 1];
      }
    });

    // Persist new status for buyer/seller sync
    _persistStatusToSupabase();
  }

  void _rejectCurrentStep() {
    // Mark the current step as rejected (generic behavior)
    setState(() {
      final idx = _statusList.indexWhere((s) => s.status == _currentStatus);
      if (idx != -1) {
        final s = _statusList[idx];
        final rejectedSubtitle = (_currentStatus == OrderStatus.paymentConfirmation)
            ? 'Payment rejected'
            : 'Step rejected';
        _statusList[idx] = OrderStatusData(
          status: s.status,
          title: s.title,
          subtitle: rejectedSubtitle,
          timestamp: DateTime.now(),
          isCompleted: false,
          estimatedTime: s.estimatedTime,
        );
      }
    });
    _showSnackBar('Current step rejected');

    // Persist rejection state as generic "rejected" status
    _persistStatusToSupabase(rejected: true);
  }

  double _computeSubtotal(List<OrderItem> items) {
    // Each item's price is already the line total (unitPrice * quantity) coming from the cart
    return items.fold(0.0, (sum, it) => sum + it.price);
  }

  double _computePlatformFee(List<OrderItem> items) {
    final totalQty = items.fold<int>(0, (sum, it) => sum + it.quantity);
    return totalQty <= 10 ? 10.0 : 15.0;
  }

  double _computeTax(double subtotal) {
    return subtotal * 0.08; // 8% tax
  }

  double _computeGrandTotal(List<OrderItem> items) {
    final subtotal = _computeSubtotal(items);
    final platform = _computePlatformFee(items);
    final tax = _computeTax(subtotal);
    return subtotal + platform + tax;
  }

  Future<void> _confirmRemoveOrderItem(OrderItem item) async {
    final shouldDelete = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Remove item?'),
        content: const Text('Do you want to remove this product from this order view?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('Keep'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Delete'),
          ),
        ],
      ),
    );

    if (shouldDelete == true) {
      setState(() {
        _orderItems.removeWhere((it) => it.id == item.id);
        _totalAmount = _computeGrandTotal(_orderItems);
      });
    }
  }

  void _initializeOrderData() {
    _statusList = [
      OrderStatusData(
        status: OrderStatus.confirmed,
        title: 'Order Confirmed',
        subtitle: 'Awaiting confirmation',
        timestamp: null,
        isCompleted: false,
      ),
      OrderStatusData(
        status: OrderStatus.packed,
        title: 'Order Packed',
        subtitle: 'Your order has been packed and is ready to go',
        isCompleted: false,
      ),
      OrderStatusData(
        status: OrderStatus.paymentConfirmation,
        title: 'Payment Confirmation',
        subtitle: 'Confirm or reject payment',
        isCompleted: false,
      ),
      OrderStatusData(
        status: OrderStatus.delivered,
        title: 'Order Delivered',
        subtitle: 'Order delivered successfully',
        isCompleted: false,
      ),
    ];

    _orderItems = [];
  }

  void _loadOrderData() {
    // Get order ID from route arguments if provided
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      final args =
          ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
      // Default to non-participant until valid args processed
      bool hasValidArgs = false;
      if (args != null) {
        setState(() {
          if (args['orderId'] != null) {
            _orderId = args['orderId'];
          }
          final items = args['items'];
          _buyerEmail = (args['buyerEmail'] as String?);
          _buyerId = (args['buyerId'] as String?);
          if (items is List && items.isNotEmpty) {
            _orderItems = items.map<OrderItem>((e) {
              final m = e as Map;
              // Keep farmer name from first item if provided
              _farmerName ??= (m['farmerName'] as String?)?.toString();
              // Capture owner id to determine permissions
              _ownerId ??= (m['ownerId'] as String?)?.toString();
              // capture seller coords if present
              final latNum = m['latitude'];
              final lonNum = m['longitude'];
              final lat = (latNum is num) ? latNum.toDouble() : null;
              final lon = (lonNum is num) ? lonNum.toDouble() : null;
              if (lat != null && lon != null && _sellerPos == null) {
                _sellerPos = LatLng(lat, lon);
              }
              return OrderItem(
                id: (m['id'] ?? '').toString(),
                name: (m['name'] ?? 'Item').toString(),
                imageUrl: (m['imageUrl'] ?? '').toString(),
                quantity: (m['quantity'] is num)
                    ? (m['quantity'] as num).toInt()
                    : int.tryParse(m['quantity']?.toString() ?? '1') ?? 1,
                price: (m['price'] is num)
                    ? (m['price'] as num).toDouble()
                    : double.tryParse(m['price']?.toString() ?? '0') ?? 0.0,
                status: 'Ready',
                statusColor: Colors.green,
              );
            }).toList();
            // Compute totals to match cart summary
            _totalAmount = _computeSubtotal(_orderItems);
            // Determine if current user is the owner
            final me = SupabaseService.currentUserId;
            _isOwner = (me != null && _ownerId != null && me == _ownerId);
            _isParticipant = me != null && (me == _ownerId || me == _buyerId);
            _isBuyer = me != null && _buyerId != null && me == _buyerId && !_isOwner;
            hasValidArgs = _orderId.isNotEmpty && _orderItems.isNotEmpty && _isParticipant;
          }
        });
      }
      if (!hasValidArgs) {
        setState(() {
          _isParticipant = false;
          _orderItems = [];
          _orderId = '';
        });
      }

      // Initial sync from order_tracking so buyer sees latest status immediately
      if (_orderId.isNotEmpty) {
        SupabaseService.getOrderTrackingStatus(_orderId).then((status) {
          if (!mounted) return;
          if (status != null && status.isNotEmpty) {
            _applyRemoteStatus(status);
          }
        });

        // Load any existing payment proofs
        SupabaseService.listPaymentProofs(_orderId).then((urls) {
          if (!mounted) return;
          setState(() {
            _paymentProofUrls = urls;
          });
        });

        // Start listening to shared order status for live updates
        SupabaseService.streamOrderTrackingById(_orderId).listen((row) {
          if (!mounted) return;
          setState(() {
            _orderRow = row;
            if (row != null && row['status'] is String) {
              _applyRemoteStatus(row['status'] as String);
            }
          });
        });
      }
      // Load saved delivery address if available
      LocalStorage.loadAddress().then((addr) {
        if (!mounted) return;
        if (addr != null) {
          setState(() {
            _deliveryAddress = (addr['label'] as String?) ?? '';
            final lat = (addr['lat'] as num?)?.toDouble();
            final lng = (addr['lng'] as num?)?.toDouble();
            if (lat != null && lng != null) {
              _buyerPos = LatLng(lat, lng);
            }
          });
        }
      });
    });

    // Simulate loading
    Future.delayed(const Duration(seconds: 1), () {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    });
  }

  void _applyRemoteStatus(String status) {
    OrderStatus? mapped;
    switch (status) {
      case 'confirmed':
        mapped = OrderStatus.confirmed;
        break;
      case 'packed':
        mapped = OrderStatus.packed;
        break;
      case 'payment_confirmation':
        mapped = OrderStatus.paymentConfirmation;
        break;
      case 'delivered':
        mapped = OrderStatus.delivered;
        break;
      default:
        return;
    }
    final provided = _statusList.map((e) => e.status).toList();
    if (!provided.contains(mapped)) return;
    _currentStatus = mapped;
    for (var i = 0; i < _statusList.length; i++) {
      final s = _statusList[i];
      final statusIndex = provided.indexOf(s.status);
      final mappedIndex = provided.indexOf(mapped);
      // For seller/owner view, only steps BEFORE the current mapped step
      // should be marked completed so that the current step still shows
      // approve/reject buttons. For buyer view, all steps up to and
      // including the current mapped step can be considered completed.
      final bool shouldComplete = _isOwner
          ? statusIndex < mappedIndex
          : statusIndex <= mappedIndex;
      _statusList[i] = OrderStatusData(
        status: s.status,
        title: s.title,
        subtitle: s.subtitle,
        timestamp: shouldComplete
            ? (s.timestamp ?? DateTime.now())
            : s.timestamp,
        isCompleted: shouldComplete,
        estimatedTime: s.estimatedTime,
      );
    }
  }

  Future<void> _persistStatusToSupabase({bool rejected = false}) async {
    if (_orderId.isEmpty) return;
    try {
      String statusStr;
      if (rejected) {
        statusStr = 'rejected';
      } else {
        switch (_currentStatus) {
          case OrderStatus.confirmed:
            statusStr = 'confirmed';
            break;
          case OrderStatus.packed:
            statusStr = 'packed';
            break;
          case OrderStatus.paymentConfirmation:
            statusStr = 'payment_confirmation';
            break;
          case OrderStatus.outForDelivery:
            statusStr = 'out_for_delivery';
            break;
          case OrderStatus.delivered:
            statusStr = 'delivered';
            break;
          case OrderStatus.readyForPickup:
            statusStr = 'ready_for_pickup';
            break;
          case OrderStatus.preparing:
            statusStr = 'preparing';
            break;
        }
      }
      await SupabaseService.updateOrderTrackingStatus(
        orderId: _orderId,
        status: statusStr,
      );
      // Mirror to 'orders' table so overviews reflect the latest status
      await SupabaseService.updateOrderStatus(orderId: _orderId, status: statusStr);
    } catch (_) {
      // ignore failures; UI will still update locally
    }
  }

  void _refreshOrderStatus() {
    HapticFeedback.lightImpact();
    setState(() {
      _isLoading = true;
    });

    // Simulate API refresh
    Future.delayed(const Duration(seconds: 2), () {
      if (mounted) {
        setState(() {
          _isLoading = false;
          // Potentially update status or add new timestamp
        });
        _showSnackBar('Order status updated');
      }
    });
  }

  void _chatWithFarmer() {
    final me = SupabaseService.currentUserId;
    final ids = [if (me != null) me, 'support']..sort();
    final chatId = '${ids.first}_${ids.last}';
    Navigator.pushNamed(
      context,
      AppRoutes.chat,
      arguments: {
        'chatId': chatId,
        'peerName': _farmerName ?? 'Support',
      },
    );
  }

  void _callFarmer() {
    _showSnackBar('Calling farmer...');
    // Make phone call
  }

  void _callDriver() {
    _showSnackBar('Calling driver...');
    // Make phone call to driver
  }

  void _trackLiveLocation() {
    _showSnackBar('Opening live tracking...');
    // Open detailed map view
  }

  void _toggleNotifications() {
    setState(() {
      _notificationsEnabled = !_notificationsEnabled;
    });
    _showSnackBar(_notificationsEnabled
        ? 'Notifications enabled'
        : 'Notifications disabled');
  }

  void _getNeedHelp() {
    Navigator.pushNamed(context, AppRoutes.aiChat);
  }

  Future<void> _openWhatsAppWithSeller() async {
    try {
      final sellerId = _ownerId;
      if (sellerId == null || sellerId.isEmpty) {
        _showSnackBar('Seller info not available');
        return;
      }
      final prof = await SupabaseService.getProfile(sellerId);
      final phone = (prof?['phone'] as String?)?.trim();
      if (phone == null || phone.isEmpty) {
        _showSnackBar('Seller phone number not available');
        return;
      }
      await WhatsAppService.openWhatsApp(
        phone,
        message: 'Hi! I have a question about order $_orderId.',
      );
    } catch (_) {
      _showSnackBar('Could not open WhatsApp');
    }
  }

  void _showSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        behavior: SnackBarBehavior.floating,
        margin: const EdgeInsets.all(16),
      ),
    );
  }

  Color _getStatusColor() {
    // Use a strong red for any non-delivered step so progress changes are obvious,
    // and green only when the order is fully delivered.
    if (_currentStatus == OrderStatus.delivered) {
      return Colors.green;
    }
    return Colors.red;
  }

  String _getStatusText() {
    if (_currentStatus == OrderStatus.confirmed) {
      final idx = _statusList.indexWhere((s) => s.status == OrderStatus.confirmed);
      final confirmedCompleted = idx != -1 ? _statusList[idx].isCompleted : false;
      return confirmedCompleted ? 'Order Confirmed' : 'Awaiting Confirmation';
    }
    switch (_currentStatus) {
      case OrderStatus.preparing:
        return 'Preparing';
      case OrderStatus.readyForPickup:
        return 'Ready for Pickup';
      case OrderStatus.packed:
        return 'Order Packed';
      case OrderStatus.paymentConfirmation:
        return 'Payment Confirmation';
      case OrderStatus.outForDelivery:
        return 'Out for Delivery';
      case OrderStatus.delivered:
        return 'Order Delivered';
      case OrderStatus.confirmed:
        // handled above
        return 'Awaiting Confirmation';
    }
  }

  VoidCallback? _buildApproveCallback() {
    if (!_isParticipant) return null;
    final isConfirmedStep = _currentStatus == OrderStatus.confirmed;
    if (_isBuyer) {
      // Buyer (BOUGHT): no tick/cross actions for any steps
      return null;
    }
    // Seller (SOLD): allow actions only for steps after confirmation
    if (_isOwner && !isConfirmedStep) {
      return _approveCurrentStep;
    }
    return null;
  }

  VoidCallback? _buildRejectCallback() {
    if (!_isParticipant) return null;
    final isConfirmedStep = _currentStatus == OrderStatus.confirmed;
    if (_isBuyer) {
      // Buyer (BOUGHT): no tick/cross actions for any steps
      return null;
    }
    // Seller (SOLD): allow actions only for steps after confirmation
    if (_isOwner && !isConfirmedStep) {
      return _rejectCurrentStep;
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Order Tracking',
          style: GoogleFonts.inter(
            fontSize: 20,
            fontWeight: FontWeight.w600,
          ),
        ),
        actions: [
          IconButton(
            onPressed: _openWhatsAppWithSeller,
            icon: const Icon(Icons.chat),
            color: Colors.green,
          ),
          IconButton(
            onPressed: _toggleNotifications,
            icon: Icon(
              _notificationsEnabled
                  ? Icons.notifications_active
                  : Icons.notifications_off,
            ),
          ),
          PopupMenuButton<String>(
            onSelected: (value) {
              switch (value) {
                case 'refresh':
                  _refreshOrderStatus();
                  break;
                case 'share':
                  _showSnackBar('Sharing order details...');
                  break;
                case 'help':
                  _getNeedHelp();
                  break;
              }
            },
            itemBuilder: (context) => [
              PopupMenuItem(
                value: 'refresh',
                child: Row(
                  children: [
                    const Icon(Icons.refresh),
                    const SizedBox(width: 8),
                    Text('Refresh', style: GoogleFonts.inter()),
                  ],
                ),
              ),
              PopupMenuItem(
                value: 'share',
                child: Row(
                  children: [
                    const Icon(Icons.share),
                    const SizedBox(width: 8),
                    Text('Share', style: GoogleFonts.inter()),
                  ],
                ),
              ),
              PopupMenuItem(
                value: 'help',
                child: Row(
                  children: [
                    const Icon(Icons.help_outline),
                    const SizedBox(width: 8),
                    Text('Help', style: GoogleFonts.inter()),
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : (!_isParticipant || _orderId.isEmpty || _orderItems.isEmpty)
              ? Center(
                  child: Padding(
                    padding: const EdgeInsets.all(24),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.inventory_2_outlined, size: 48, color: Colors.grey),
                        const SizedBox(height: 12),
                        Text(
                          'No order to show',
                          style: GoogleFonts.inter(fontSize: 16, fontWeight: FontWeight.w600),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          'Order tracking is visible only to the buyer and the product owner.',
                          textAlign: TextAlign.center,
                          style: GoogleFonts.inter(color: Colors.grey),
                        ),
                        const SizedBox(height: 16),
                        OutlinedButton(
                          onPressed: () => Navigator.pushNamed(context, AppRoutes.consumerMarketplace),
                          child: const Text('Browse Products'),
                        ),
                      ],
                    ),
                  ),
                )
              : RefreshIndicator(
                  onRefresh: () async {
                    _refreshOrderStatus();
                  },
                  child: SingleChildScrollView(
                    physics: const AlwaysScrollableScrollPhysics(),
                    child: Column(
                      children: [
                        // Order Header
                        OrderHeaderWidget(
                          orderNumber: _orderId.isNotEmpty ? _orderId : _orderNumber,
                          orderDate: _orderDate,
                          totalAmount: _totalAmount,
                          currentStatus: _getStatusText(),
                          statusColor: _getStatusColor(),
                        ),

                        // Order Status Timeline
                        OrderStatusTimeline(
                          statusList: _statusList,
                          currentStatus: _currentStatus,
                          onApproveCurrent: _buildApproveCallback(),
                          onRejectCurrent: _buildRejectCallback(),
                        ),

                        // Buyer actions for payment (available from Confirmed step onward)
                        if (_isBuyer && (_currentStatus == OrderStatus.confirmed || _currentStatus == OrderStatus.packed || _currentStatus == OrderStatus.paymentConfirmation))
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                            child: Row(
                              children: [
                                Expanded(
                                  child: OutlinedButton.icon(
                                    onPressed: _launchUpiPay,
                                    icon: const Icon(Icons.payment),
                                    label: Text('Pay via UPI', style: GoogleFonts.inter(fontWeight: FontWeight.w600)),
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: ElevatedButton.icon(
                                    onPressed: _uploadPaymentProof,
                                    icon: const Icon(Icons.upload_file),
                                    label: Text('Upload proof', style: GoogleFonts.inter(fontWeight: FontWeight.w600)),
                                  ),
                                ),
                              ],
                            ),
                          ),

                        // Show proofs for seller during payment confirmation step
                        if (_isOwner && _paymentProofUrls.isNotEmpty)
                          Container(
                            margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                            padding: const EdgeInsets.all(12),
                            decoration: BoxDecoration(
                              color: Theme.of(context).cardColor,
                              borderRadius: BorderRadius.circular(12),
                              boxShadow: [BoxShadow(color: Colors.black.withOpacity(0.05), blurRadius: 6)],
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text('Payment Proofs', style: GoogleFonts.inter(fontWeight: FontWeight.w700)),
                                const SizedBox(height: 8),
                                SizedBox(
                                  height: 88,
                                  child: ListView.separated(
                                    scrollDirection: Axis.horizontal,
                                    itemBuilder: (_, i) => ClipRRect(
                                      borderRadius: BorderRadius.circular(8),
                                      child: InkWell(
                                        onTap: () async {
                                          final url = _paymentProofUrls[i];
                                          final uri = Uri.parse(url);
                                          await launchUrl(uri, mode: LaunchMode.externalApplication);
                                        },
                                        child: Image.network(_paymentProofUrls[i], width: 120, height: 88, fit: BoxFit.cover),
                                      ),
                                    ),
                                    separatorBuilder: (_, __) => const SizedBox(width: 8),
                                    itemCount: _paymentProofUrls.length,
                                  ),
                                ),
                              ],
                            ),
                          ),

                        if (_isOwner && _currentStatus == OrderStatus.confirmed)
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                            child: Row(
                              children: [
                                Expanded(
                                  child: ElevatedButton.icon(
                                    onPressed: _approveCurrentStep,
                                    icon: const Icon(Icons.check_circle_outline),
                                    label: Text('Accept Order', style: GoogleFonts.inter(fontWeight: FontWeight.w600)),
                                  ),
                                ),
                                const SizedBox(width: 12),
                                Expanded(
                                  child: OutlinedButton.icon(
                                    onPressed: _rejectCurrentStep,
                                    icon: const Icon(Icons.cancel_outlined),
                                    label: Text('Reject Order', style: GoogleFonts.inter(fontWeight: FontWeight.w600)),
                                  ),
                                ),
                              ],
                            ),
                          ),

                        // Delivery Map (show when delivery address is available)
                        if (_buyerPos != null)
                          DeliveryMapWidget(
                            buyerPosition: _buyerPos!,
                            sellerPosition: _sellerPos,
                            onTrackLive: _trackLiveLocation,
                          ),

                        // Order Items
                        OrderItemsList(
                          items: _orderItems,
                          showIndividualStatus: true,
                          onDeleteItem: _confirmRemoveOrderItem,
                        ),

                        const SizedBox(height: 100), // Space for floating button
                      ],
                    ),
                  ),
                ),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          FloatingActionButton(
            onPressed: _openWhatsAppWithSeller,
            child: const Icon(Icons.chat),
          ),
          const SizedBox(height: 12),
          FloatingActionButton.extended(
            onPressed: _getNeedHelp,
            icon: const Icon(Icons.help_outline),
            label: Text(
              'Need Help?',
              style: GoogleFonts.inter(fontWeight: FontWeight.w600),
            ),
          ),
          const SizedBox(height: 12),
          if (_isOwner && _currentStatus != OrderStatus.delivered)
            ElevatedButton.icon(
              onPressed: () {
                setState(() {
                  _currentStatus = OrderStatus.delivered;
                  final idx = _statusList.indexWhere((s) => s.status == OrderStatus.delivered);
                  if (idx != -1) {
                    final s = _statusList[idx];
                    _statusList[idx] = OrderStatusData(
                      status: s.status,
                      title: s.title,
                      subtitle: 'Order delivered successfully',
                      timestamp: DateTime.now(),
                      isCompleted: true,
                      estimatedTime: s.estimatedTime,
                    );
                  }
                });
                _persistStatusToSupabase();
                _showSnackBar('Order marked delivered');
              },
              icon: const Icon(Icons.check_circle_outline),
              label: Text('Mark Delivered', style: GoogleFonts.inter(fontWeight: FontWeight.w600)),
              style: ElevatedButton.styleFrom(backgroundColor: Colors.green, foregroundColor: Colors.white),
            )
          else if (_currentStatus == OrderStatus.delivered)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: Colors.green,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.check_circle_outline, color: Colors.white),
                  const SizedBox(width: 8),
                  Text(
                    'Delivery successful',
                    style: GoogleFonts.inter(
                      fontWeight: FontWeight.w600,
                      color: Colors.white,
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}